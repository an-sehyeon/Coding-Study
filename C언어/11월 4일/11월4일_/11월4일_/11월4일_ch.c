//
//[언어의 메모리 구조]
//
//### 메모리의 필요성 ###
//- 프로그램을 실행할 때 먼저 프로그램을 메모리에 로드(Load),
//즉 RAM(Random Access Memory)에 불러와 복사해둬야함.
//
//### 메모리 로드(Memory - Load) ###
//- 프로그램을 실행하거나 데이터를 다룰 때, 해당 프로그램이나 데이터를 하드 디스크,
//SSD, 또는 다른 저장 매체에서 메모리로 복사하는과정을 "로드한다"라고 표현함
//RAM은 하드 디스크보다 훨씬 빠른 읽기 및 쓰기 속도를 제공함.
//
//
//==============================================================================
//
//
//[1. 코드 영역(Code Segment]
//
//	- 실행할 프로그램의 기계어 코드가 저장되는 메모리 영역으로 텍스트(Code) 영역이라고도 함.
//
//	- 프로그램이 실행될 때 CPU(Central Processing Unit), 즉 중앙처리 장치는
//	코드 영역에 저장된 명령어를 하나씩 가져가저 정해진 순서대로 실행함.
//	- 이를 절차 지향이라고 부름
//
//	==============================================================================
//
//	[2. 데이터 영역(Data Segment) (전역 변수 영역)]
//
//	- 프로그램의 전역 변수와 정적(static) 변수가 저장되는 영역임.
//	- 프로그램 시작과 동시에 메모리 공간에 할당되며, 프로그램이 종료되면 소멸함.
//	- 프로그램 어디에서든 접근 할 수 있다.
//
//	- 초기화된 데이터와 초기화되지 않은 데이터 영역으로 나뉨.
//	- 초기화된 데이터는 프로그램 시작 시 초기값을 가지며,
//	초기화되지 않은 데이터는 0 또는 NULL값으로 초기화됨.
//
//	==============================================================================
//
//	[3. 스택 영역(stack)]
//
//	- 스택((stack) : 데이터를 쌓는 자료구조
//		- 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역임.
//		- 함수의 호출과 함께 할당도며, 함수의 호출이 완료되면 소멸함.
//		- 스택 영역에 저장되는 함수의 호출 정보를 스택 프레임(Stack Frame)이라고 함.
//
//
//		## 스택 프레임(Stack Frame) ##
//		- 함수가 호출되면 스택에는 함수의 '매개변수', 호출이 끝난 뒤 돌아갈 '반환 주소값', 함수에서 선언된
//		'지역변수' 등이 저장됨.
//
//		- 스택 영역에 차례대로 저장되는 함수의 호출정보 및 상태정보를 스택 프레임이라고 하며, 스택 프레임에 저장.
//
//		- 후입선출 방식덕분에 함수가 호출되고 호출되기 이전 상태로 되돌아 갈 수 있음.
//
//
//
//		## 높은 주소와 낮은 주소 ##
//		- 메모리 주소는 아래로 갈수록 증가, 위로 갈수록 감소함
//
//		- 스택의 맨 위(가장 낮은 주소)는 현재 실행 중인 함수의 스택 프레임이 위치하는 지점이고 이 위에
//		새로운 스택 프레임이 쌓임.
//
//		- '높은 주소'와 '낮은 주소'는 메모리 주소의 상대적 위치, 즉 할당 방향을 나타내고 컴퓨터 아키텍처에 따라 따름.
//		- 일반적으로 x86 아키텍처에서는 스택이 높은 주소에서 낮은 주소로 할당.
//		- 컴퓨터 아키텍처 및 운영 체제에 따라 다를 수 있으며, 주소의 방향을 나타냄.
//		- 스택의 "높은 주소"는 일반적인 메모리에서의 "높은 주소"와 반대 개념으로,
//		스택 메모리에서는 높은 주소가 낮은 메모리 주소를 가리킴.
//
//
//		일반 메모리		스택 메모리
//		(높은 주소			낮은주소 < -- - 스택 포인터가 가리키는 위치
//		((현재 실행 중인 함수의 스택 프레임이 위치하는 지점)
//			(
//				(
//					(낮은 주소			높은 주소
//
//						- 푸쉬(PUSH) 동작으로 데이터를 저장하고, 팝(pop)동작으로 데이터 인출
//						- 후입선출(LIFO, Last - In First - Out) 방식에 따라 동작, 즉 가장 늦게 저장된 데이터가 가장 먼저 인출.
//						- 새로운 데이터가 스택에 푸시될 때 스택 포인터가 감소하고, 데이터가 팝될 때 스택 포인터가 증가함.
//						- 스택 영역은 메모리의 높은 주소에서 낮은 주소의 방황으로 할당
//
//						- 스택이 위에서 아래로 쌓이는 것은 스택 메모리를 효율적으로 사용하기 위함.
//						- 스택이 아래에서 위로 쌓이면 스택의 크기를 미리 정할 필요 x, 즉, 스택이 필요한 만큼 메모리를 사용할 수 있음.
//						- 스택의 크기를 동적으로 조정하기 위해 메모리를 아래에서 위로 할당하는 것이 효율적임.
//
//						==============================================================================
//
//						[4. 힙 영역(Heap)]
//
//						- 사용자가 직접 관리할 수 있고 관리해야만 하는 메모리 영역
//						- 즉, 사용자에 의한 메모리 동적 할당 및 해제
//
//						- 일반적으로 메모리 누수와 같은 문제를 방지하기 위해 힙에서 할당한 메모리는 반드시 프로그램에서 해제해야 함.
//						- 힙 영역은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당
//
//						## 동적할당(Dynamic Allocation) ##
//						- 데이터 영역과 스택 영역에 할당되는 메모리의 크기는 컴파일 타임(Compile Time)에 미리 결정
//						- 힙 영역의 크기는 프로그램이 실행되는 도중인 런 타임(Run Time)에 사용자가 직접 결정
//						- 이를 메모리의 동적 할당이라고 함.
//						- EX) malloc()함수, free()함수, calloc()함수 등
//
//
//					==============================================================================
//
//					[함수]
//
//					- 함수(function)란 ? : 하나의 특정한 목적의 작업을 수행하기 위한 코드들의 집합
//					- 이것 역시 프로그램의 일종인데, IDLE과 같은 개발자를 위한 Tool도 프로그램이지만
//					함수는 그 내부에 좀더 작은 단위의 프로그램으로 볼 수 있다.
//
//					- 즉 프로그램은 여러 개의 함수들로 이루어져 있다.
//					- 제일 먼저 호출되는 함수는 main()함수
//
//					- 함수는 모듈화에 사용됨
//
//					- 함수 호출(function call)이란 ? : 간단히 말해서, 함수 사용을 위해서 함수를 부른다.호출한다는 의미
//					- 함수는 입력을 받아 출력을 생성하는데 이는 커피자판기로 예로 들 수 있다.
//					- EX) 커피자판기에 동전을 넣는다(입력)
//				- EX) 내가 원하는 커피가 나온다(출력)
//			- EX) 입력값은 100원, 200원, 500원, 1000원 등이 있을 수 있고
//			- EX) 출력값은 카라멜 마끼아또, 에스프레소, 아메리카노 등이 있을 수 있다.
//
//
//		==============================================================================
//
//		[01 모듈]
//
//		- 모듈이란 ? : 프로그래밍에서의 모듈은 프로그램을 구성하는 구성 요소의 일부
//		- EX) 계산기의 더하기 기능, 빼기 기능 등등
//	- 이 모듈은 관련 데이터와 함수들의 집합, 즉 이런것들이 모여서 모듈을 형성함.
//	- EX) 더하기 기능은 여러 함수와 코드들이 합쳐져서 만들어진 기능
//	- 모듈화란 ? : 각각의 기능들을 파일별로 나뉘어 놓은걸 모듈화라고 한다.
//	- EX) 계산기의 더하기나 빼기, 나누기 기능들을 파일별로 나누어 관리하는 것이 모듈화했다 라고 함
//
//	- 모듈러 프로그래밍 : 모듈 개념을 사용하는 프로그래밍 기법
//	- 모듈화의 장범 : 하나의 프로그램(계산기)를 만들 때 이식, 확장, 유지보수 등이 좋도록 한다.
//
//
//	==============================================================================
//
//	[02 함수의 종류 및 형태]
//
//	- 1. 사용자 정의 함수 : 개발을 위해 개발자가 직적 만드는 함수
//	- 2. 라이브러리 함수 : 개발자들이 사용하기 편하게 미리 만들어져 제공되는 함수
//
//
//	- 함수의 헤더(function header)
//	- 1. 반환형 : 반환형은 함수가 반환하는 값의 데이터 타입을 정의한다.반환값이 없는 경우 void라는 반환형을 사용한다.
//
//	- 2. 함수 이름 : 함수 이름은 함수를 호출하기 위한 식별자이다.
//	함수 이름은 변수 이름과 마찬가지로 유효한 식별자로 작성되어야 한다.
//
//	- 3. 매개 변수 : 매개 변수는 함수가 호출될 때 전달되는 값을 받아들이는 변수이다.
//	매개 변수는 함수 내에서 지역 변수처럼 작동한다.
//	함수 호출 시에는 매개 변수에 전달되는 값의 데이터 타입의 개수가 일치해야한다.
//
//	- 함수의 몸체(function body) ==> {}
//
//
//
//
//
//#include <stdio.h>
//
//int add(int x, int y) {			// 함수명 add 생성
//	int sum = x + y;			// sum 지역변수는 x + y값
//	return sum;			// sum변수값 리턴
//}
//
//int main() {
//
//	int num1 = 3;			// num1 값에 인자값 3 
//	int num2 = 5;			// num2 값에 인자값 5
//	int result = add(num1, num2);	// add함수를 호출해 result변수에 대입 x,y인자값을 num1,num2값 대입
//	printf("The result is %d\n", result);
//
//
//	return 0;
//}
//
//==============================================================================
//
//[int main(void)]
//
//- 실제로 void main()을 사용하면 오류가 나진 않음.
//- return type(반환 자료형)에 int를 사용하는 것은 표준 c에서는 정상적인 실행의 경우 main함수는
//return 0을 하기로 약속되어 있기 때문(이는 실행 성공을 의미)
//- 그러나 return 0; 을 개발자가 하지 않아도 컴파일러가 허용하는 범위이기 때문에 return 0; 없이도 실행이 가능
//
//- 또한 main()은 return 0을 하기 때문에 int main()으로 적어줘야하지만 void main()으로 적는 것 또한
//컴파일러가 허용하는 범위 내 이기에 에러없이 실행이 됨.
//
//- 추가적으로 main 함수가 반환되는 값을 사용하는 경우는 매우 드물기 때문에
//void main()은 일반적으로 프로그램의 실행에 아무런 문제가 없다.
//
//
//==============================================================================
//
//[03 인수(argument)와 매개변수(parameter)]
//
//- 인수란 ? : 함수 호출 시 함수로 값을 전달해주는 변수
//
//- 매개변수란 ? : 함수 호출 시 인수로 전달된 값을 함수 내부에서 사용할 수 있도록 하는 변수
//- 매개변수는 함수 내에서 지역변수로 사용됨.
//- 매개변수는 함수 호출 시에 전달된 인수(argument)값을 저장.
//
//
//==============================================================================
//
//[04 지역변수(Local Variable)]
//
//- 특정구역({}) 내에서 생성되어 그 구역에서만 사용 가능한 변수, 즉 함수 속에서 선언되어 함수 속에서만
//사용 가능한 변수
//- 함수나{}이 끝나게 되면 메모리에서 소멸
//
//
//==============================================================================
//
//[05 전역변수(Global Variable)]
//
//- 어느 위치에서든 호출하면 사용이 가능한 변수 즉, 함수 밖에서 선언하여 클래스 전체에서 사용이 가능한 변수
//
//- 1. 전역변수는 프로그램 전체에서 사용 가능한 변수이다.
//- 프로그램이 종료될 때까지 메모리에서 유지된다.
//
//- 2. 전역변수는 프로그램 내에서 어디에서든지 사용할 수 있으므로,
//프로그램의 다른 부분에서 변수명이 중복되어 사용될 가능성이 있다.
//따라서 전연변수는 가능한 사용을 최소화해야 한다.
//
//
//==============================================================================
//
//[06 void(빈, 비어있는)]
//
//- 함수나 포인터를 정의할 때 사용한다.
//- 1. void 함수
//- 2. void 포인터
//
//
//- 1. 함수의 반환형으로 void를 사용하면, 해당 함수는 반환값이 없다는 것을 나타낸다.
//
//
//#include <stdio.h>
//void helloworld() {			// 함수 생성
//	printf("hello world\n");	// hello world 문자 출력
//}
//int main(void) {
//
//	helloworld();		// 함수 호출
//
//	return 0;
//}
//
//
//
//-2. 포인터로서의 void
//
//- 포인터를 선언할 때 void를 사용하면, 어떤 데이터 타입의 메모리 주소든 포인터 변수에 할당0
//이를 void 포인터라고 함.
//- void 포인터는 연산x, 그렇기 때문에 연산 가능한 데이터 타입으로 캐스팅하여 사용함.
//
//
//#include <stdio.h>
//int main() {
//
//	int num = 10;
//	float fnum = 3.14;
//
//	void* ptr;				// 포인터형 prr변수
//	ptr = &num;			// ptr을 num변수에 대입
//	printf("num : %d\n", *(int*)ptr);	// 포인터 변수ptr을 int형으로 출력
//
//	ptr = &fnum;			// ptr을 fnum변수에 대입
//	printf("num : %f\n", *(float*)ptr);	// 포인터 변수 ptr을 float형으로 출력
//
//	return 0;
//}
//
//==============================================================================
//
//[07 static 변수(정적 변수)]
//
//- static은 프로그램의 수명 주기와 관련된 변수임.
//- static 변수는 프로그램이 실행되고 종료될 때까지 존재
//
//- 1. 수명 주기 : static 변수는 프로그램이 실행되고 종료될 때가지 메모리에 남아 있음.
//이는 해당 변수가 함수의 호출이 끝난 후에도 유지되며, 다음 번 함수 호출 시에도 이전 값이 유지된다는 것을 의미
//
//- 2. 스코프 : static 변수는 정의된 함수 내에서만 접근 가능
//다른 함수에서는 직접적으로 접근할 수 없음.
//
//- 3. 초기화 : static 변수는 한번만 초기화
//함수가 여러번 호출되더라도 static 변수의 초기화는 처음 호출 시에만 이루어짐.
//
//- 4. 저장 위치 : static 변수는 프로그램의 데이터 세그먼트(데이터 영역)에 저장됨.
//이는 프로그램의 시작 시에 할당되고 종료 시에 해제됨.
//
//
//
//#include <stdio.h>
//void test() {
//	static int count = 0;		// 정적 변수 선언 및 초기화
//	count++;				// count 변수는 계속 유지되며 값이 유지됨.
//	printf("Count : %d\n", count);
//}
//int main(void) {
//	test();				// Count : 1 출력
//	test();				// Count : 2 출력
//	test();				// Count : 3 출력
//	return 0;
//}
//
//
//==============================================================================
//
//함수 심화
//
//
//[01 포인터와 함수 포인터]
//
//- ## 포인터(Pointer) ##
//- 포인터는 메모리 주소를 저장하고 참조하는 변수
//- 메모리 주소는 변수, 배열, 구조체, 함수 등 다양한 데이터 요소의 위치를 가리킴
//
//
//## 포인터의 선언과 초기화 ##
//- 1. 포인터의 선언과 초기화
//int x = 10;	// 정수 변수 선언
//int* ptr;	// 정수 포인터 선언
//ptr = &x;	// 포인터에 변수 x의 주소를 할당
//
//-1 - 1. 포인터를 사용하여 값 접근
//int value = *ptr;	// 포인터를 사용하여 x의 값을 읽음
//
//
//-2. 포인터 연산
//- 포인터는 산술 연산을 수행할 수 있으며, 배열의 요소에 접근할 때 특히 유용
//int arr[] = { 10, 20, 30, 40 };	// 배열 선언
//int* ptr = arr;			// 배열의 첫 번째 요소를 가리키는 포인터
//int thirdElement = *(ptr + 2);	// 세 번째 요소에 접근
//
//
//## 함수 포인터(Function Pointer) ##
//- 함수 포인터는 함수의 주소를 저장하고 해당 함수를 실행할 수 있는 포인터
//- 함수 포인터를 사용하면 런타임에 다양한 함수를 선택적으로 호출할 수 있음
//- 함수 포인터는 콜백 함수, 동적 함수 호출, 이벤트 처리 등 다양한 상황에서 사용
//
//- 1. 함수 포인터의 선언
//
//int (*functionPtr) (int, int);		// int를 반환하고 int 두 개를 인수로 받는 함수 포인터 선언
//
//
//-2. 함수 포인터에 함수 할당
//
//int add(int a, int b) {
//	return a + b;
//}
//functionPtr = add;		// 함수 포인터에 add 함수 할당
//
//
//-3. 함수 포인터를 사용하여 함수 호출
//
//int result = functionPtr(5, 3);	// 함수 포인터를 사용하여 add 함수 호출
//
//==============================================================================
//
//[02 콜백 함수 구현]
//
//- 콜백 함수(callback Function) : 다른 함수에 의해서 호출되는 함수
//- 일반적으로 다른 함수의 작업 중에 특정 이벤트 또는 조건이 발생했을 때 호출되며,
//-이때 콜백 함수는 특정 작업을 수행하거나 어떤 동작을 실행
//
//- 1. 이벤트 처리
//- 그래픽 사용자 인터페이스(GUI)에서 버튼 클릭 또는 마우스 이동과 같은 이벤트가 발생했을 때
//특정 함수를 호출하여 해당 이벤트를 처리
//
//- 2. 비동기 작업(Asynchronous operation)
//- 여러 작업을 동시에 수행하거나, 작업을 순차적으로 실행하되 다른 작업의 완료를 기다리지 않는 방식
//- EX) 대규모 파일 다운로드, 네트워크 통신, 사용자 인터페이스 응답성(백그라운드 작업 처리),
//병렬처리(다중 코어 CPU 활용-- > 여러 작업 병렬 실행)
//
//- 비동기 작업(예 : 파일 다운로드)이 완료되면 완료 콜백 함수를 호출하여 작업 결과를 처리
//
//- 3. 사용자 지정 동작
//- 사용자가 원하는 동작을 콜백 함수로 정의하고 다른 함수(예 : 정렬 함수)가 이름 호출할 때 사용자 지정 동작을 실행
//
//
//
//#include <stdio.h>
//
//// 콜백 함수 시그니처 : 정수 2개를 입력으로 받고 정수를 반환하는 함수
//typedef int (*CallbackFunction) (int, int);
//
//int add(int a, int b) {
//	return a + b;
//}
//
//int Multiply(int a, int b) {
//	return a * b;
//}
//
//// 콜백 함수를 사용하는 함수
//int PerformOperation(int x, int y, CallbackFunction operation) {
//	return operation(x, y);
//}
//
//int main() {
//	int result1, result2;
//
//	// 덧셈 콜백 함수를 사용
//	result1 = PerformOperation(5, 3, add);
//	printf("덧셈 결과 : %d\n", result1);
//
//	// 곱셈 콜백 함수를 사용
//	result2 = PerformOperation(5, 3, Multiply);
//	printf("곱셈 결과 : %d\n", result2);
//
//	return 0;
//}
//
//
//- CallbackFunction이라는 함수 포인터 타입을 정의하고, add 및 Multiply 함수를 콜백 함수로 사용
//- PerformOperation 함수는 이러한 콜백 함수를 사용하여 다양한 연산을 수행
//
//==============================================================================
//
//
//[03 재귀 함수]
//
//- 재귀 함수(Recursion Function)
//- 자기 자신을 직접 또는 간접적으로 호출하는 프로그래밍 기법
//- 함수 내에서 자신의 함수를 호출하는 기법이라고 생각하면 됨.
//- 문제 해결 혹은 동일한 알고리즘을 적용하는데 사용
//
//
//
//재귀 함수를 사용 x
//
//#include <stdio.h>
//int factorial(int n) {			// factorial함수를 생성 int형 n이라는 매개변수 생성
//	int result = 1;
//	for (int i = 1; i <= n; i++) {	// i가 n가 같을때까지 1씩 증감
//		result *= i;		// i가 n과 같을때까지 곱해진 값을 result에 저장
//	}
//	return result;
//}
//int main(void) {
//	printf("5! = %d\n", factorial(5));	// factorial함수에 인자값 5 대입
//
//}
//
//
//
//재귀 함수를 사용 0
//
//#include <stdio.h>
//int factorial(int n) {
//	if (n == 0) {
//		return 1;
//	}
//	else {
//		return n * factorial(n - 1);
//	}
//}
//int main(void) {
//
//	printf("5! = %d\n", factorial(5));
//	// 5 * factorial(4)
//}
//
//==============================================================================
//
//
//[재귀 함수의 구조]
//
//- 재귀 함수는 항상 종료 조건을 가져야 함
//- 종료 조건이 없거나 잘못 구현된 경우, 함수가 무한히 호출되어 스택 오버플로우와 같은 오류를 일으킬 수 있음.
//
//- 재귀 함수를 사용할 때, 중요한 것은 각 호출이 서로 다른 문제 인스턴스를 다루는 것, 즉 각 호출이 독립적이라는 것을 의미.
//- 각 호출은 자체 스택 프레임을 가지며, 호출 간에 데이터를 공유하지 않아야 함.
//- 이것을 통해 작은 부분 문제를 해결하고 결합하여 원래 문제를 해결.
//
//
//피보나치 수열
//
//
//#include <stdio.h>
//
//int calculateSum(int n) {
//	if (n == 1) {
//		return 1;			// 재귀 종료 조건
//	}
//	else {
//		return n + calculateSum(n - 1);	 // 자신을 다시 호출하면서 숫자를 더해감
//	}
//}
//int main() {
//	int num;
//	printf("양의 정수를 입력하세요: ");
//	scanf_s("%d", &num);
//
//	if (num < 1) {
//		printf("양의 정수를 입력해야 합니다.\n");
//	}
//	else {
//		int result = calculateSum(num);
//		printf("1부터 %d까지의 합은 %d입니다.\n", num, result);
//	}
//	return 0;
//}
//
//- calculateSum 함수는 재귀적으로 호출되며, n이 1일 때 재귀가 종료
//
//
//==============================================================================
//
//
//[04 배열과 함수]
//
//- 배열의 이름은 0번째 인덱스 요소의 위치값, 주소값을 나타냄.
//- 이때 포인터 변수를 선언하여 사용함.
//- 포인터와 배열의 관계에서 다루었던 내용들
//- 포인터는 배열처럼 사용할 수 있다.
//
//
//
//#include <stdio.h>
//void printArray(int* arr, int size) {
//	for (int i = 0; i < size; i++) {
//		printf("%d", arr[i]);
//	}
//}
//int main() {
//	int arr[5] = { 1,2,3,4,5 };
//
//	printArray(arr, 5);
//}
//
//- printArray 함수에서는 'arr' 배열의 첫 번째 요소를 가리키는
//포인터 변수 'arr'을 사용하여 배열의 모든 요소를 출력할 수 있다.
//
//
//==============================================================================
//
//
//[문제 1]
//
//- 재귀 함수를 사용하여 주어진 배열에서 특정 값의 존재여부를 확인하는 C 프로그램을 작성
//- search 함수를 재귀 함수로 선언 및 정의하시오.
//- 1. 크기가 5인 정수형 배열 arr 선언
//- 2. 배열의 크기를 size에 초기화
//- 3. 내가 찾을 target 변수 초기화
//- 4. if문을 사용해서 내가 search 함수로 target을 찾는다면 1을 반환, 아니면 0을 반환
//- 5. target을 찾아서 1을 반환했을 때 if문에 들어와 target 출력, 아니면 target not found 출력
//
//- Tips) search()를 정의할 때, 재귀함수, 즉 자기 자신을 호출해야함.
//search()를 정의할 때, 내가 찾으려고 하는 target이 배열안에 있는지 확인하는 작업이 필요,
//size는 크기이므로 인덱스 번호로 이용
//
//
//#include <stdio.h>
//int search(int arr[], int size, int target) {
//
//	// 배열의 요소에 target있다면? return 1
//	// arr[0]이 target과 같나?
//	// arr[1]이 target과 같나?
//	// arr[2]이 target과 같나?
//	// arr[3]이 target과 같나?
//	// arr[4]이 target과 같나?
//	// arr 배열의 요소와 target이 같은지에 대한 식을 세워야함
//	// 배열의 요소에 target없다면? return 0 ==> 종료조건
//
//
//	if (size == 0) {			// 5크기의 배열 -1은 4 4번째 인덱스 값이 target과 같은지의 조건식 
//		return 0;
//	}
//	if (arr[size - 1] == target) {		// 4번째 인덱스에 해당하는 요소값이 target과 다르다면
//		return 1;
//	}
//
//	return search(arr, size - 1, target);
//
//}
//
//int main(void) {
//	int arr[] = { 1,2,3,4,5 };
//	int size = sizeof(arr) / sizeof(arr[0]);		// 20bytd / 4 byte == 5
//	int target = 3;
//
//	if (search(arr, size, target)) {			// 만약에 target이 arr 배열에 있다면 이 코드를 수행
//		printf("내가 찾을 타겟이 있습니다.");
//	}
//	else {					// 만약에 target이 arr 배열에 없다면 이 코드를 수행
//		printf("내가 찾을 타겟이 없습니다.");
//	}
//}
//
//
//==============================================================================
//
//
//[문제 2]
//
//- 팩토리얼 함수
//
//- 팩토리얼 함수는 n이 양의 정수일 때 n!의 값을 계산하는 함수이다.
//- n!은 1부터 n까지의 모든 양의 정수를 곱한다.
//- 예를 들어 5!= 1 x 2 x 3 x 4 x 5 = 120
//
//- 재귀호출 함수를 사용하여 팩토리얼 함수를 구현해 보시오
//- 함수의 이름은 factorial로 하고, 매개변수로는 양의 정수 n을 받는다.
//
//
//
//#include <stdio.h>
//
//unsigned long long factorial(unsigned int n) {
//	if (n == 0) {
//		return 1;
//	}
//	else {
//		return n * factorial(n - 1);
//	}
//}
//
//int main(void) {
//
//	unsigned int num;				//양수 데이터형 num 변수 생성
//	printf("양의 정수를 입력하세요>>");
//	scanf_s("%u", &num);
//
//	unsigned long long result = factorial(num);
//	printf("%u! = %llu\n", num, result);
//
//}
//
