//
//
//[포인터의 연산]
//
//- 포인터의 증가는 일반 변수와는 다름.
//- 가리키는 포인터의 자료형만큼 증가한다
//
//- 포인터		++연산 이후 값
//- char		1
//- short		2
//- int		4
//- float		4
//- double	8
//
//
//#include <stdio.h>
//int main() {
//
//	char* pc;
//	int* pi;
//	double* pd;
//
//	pc = (char*)10000;		// (char*)은 포인터 변수의 데이터 형식
//	pi = (int*)10000;			// (int)는 정수 자료형의 데이터 형식
//	pd = (double*)10000;		// 즉 그 형태로 만드는 것 == char형식의 포인터로 캐스팅한다고 함
//
//	printf("증가 전 pc = %p, pi = %p, pd = %p\n", (void*)pc, (void*)pi, (void*)pd);
//
//	pc++;
//	pi++;
//	pd++;
//	printf("증가 후 pc = %p, pi = %p, pd = %p\n", (void*)pc, (void*)pi, (void*)pd);
//
//	return 0;
//}

//
//================================================== =
//
//
//[문제]
//
//- 1. 변수 x를 10으로 초기화
//- 2. int형 포인터 변수 ptr을 선언하고 x의 주소를 참조
//- 3. x의 값 출력
//- 4. ptr의 값 출력
//- 5. x의 주소값 출력
//- 6. ptr이 가리키는 주소값 출력
//- 7. ptr의 주소값 출력
//
//
//#include <stdio.h>
//int main(void) {
//
//	int x = 10;
//	int* ptr = &x;
//
//	// 포인터 : 메모리 주소값을 저장하고 메모리 내의 데이터를 간접적으로 참조하는 , 접근하는 것
//	// *(포인터 연산자) : 그 변수의 값
//
//	// 변수의 값
//	printf("x의 값 : %d\n", x);
//
//	// 포인터의 값		
//	printf("ptr의 값 출력 : %d\n", *ptr);
//
//	// 변수의 주소 값	
//	printf("x의 주소 값 출력 : %p\n", &x);
//
//	// 변수의 위치값을 포인터 형태로(포인터 변수 사용) 출력		
//	printf("ptr이 가리키는 주소의 값 : %p\n", ptr);
//
//	// 포인터의 주소 값
//	printf("ptr의 주소 값 출력 %p\n", &ptr);
//
//
//
//	return 0;
//}
//
//================================================== =
//
//
//[포인터와 배열의 관계]
//
//- 1. 배열의 이름은 포인터 변수 역할을 하며 배열이 시작되는 메모리의 주소를 확인할 수 있다.
//- 2. 배열의 이름은 값을 저장할 수는 없다.
//
//- 인덱스 번호를 통해 각 요소에 순차적인 접근이 가능한 이유는 배열의 각 요소가 메모리 공간에 나란히
//놓여있기 때문.
//
//
//#include <stdio.h>
//int main(void) {
//
//	int arr[3] = { 10,20,30, };
//
//	printf("%d\n", arr[0]);
//	printf("%d\n", arr[1]);
//	printf("%d\n", arr[2]);
//
//	return 0;
//}
//
//
//================================================== =
//
//
//[배열의 주소 확인]
//
//#include <stdio.h>
//int main(void) {
//
//	int arr[3] = { 10,20,30 };
//
//	printf("배열 각 요소의 주소 확인\n");
//	printf("배열의 이름 : %p\n", arr);
//	printf("첫번째 요소 : %p\n", &arr[0]);
//	printf("두번째 요소 : %p\n", &arr[1]);
//	printf("세번째 요소 : %p\n", &arr[2]);
//
//	return 0;
//}
//
//
//- 실행결과에서 KeyPoint
//- 1. 각 요소의 주소값을 보면 순차적으로 4바이트씩 증가함.
//- 2. 배열의 이름은 그 자체로 포인터 변수의 역할을 하며,
//이는 배열의 첫번째 요소의 메모리 주소값과 동일
//- 3. 배열명을 포인터 상수(Constant Pointer)라고 함. ####
//
//================================================== =
//
//
//[참조 타입과 원시 타입]
//
//- 원시 타입이란 프로그래밍 언어에서 기본적으로 제공하는 데이터 유형
//보통 낮은 수준의 데이터 유형(각 자료형들)
//
//- 참조란 = 변수나 메모리 위치에 접근하여 해당 데이터를 읽거나 수정하는 것을 의미
//- 참조 타입이란 프로그래밍 언어에서 변수가 메모리의 주소(참조)를 저장하는 데이터 유형
//
//
//#include <stdio.h>
//int main(void) {
//
//
//	// java나 python에서는 배열은 참조타입.
//	// c에서는 값 타입으로 취급
//	// --> 포인터는 참조타입
//
//	int arr[1] = { 3 };
//
//	int num = 3;
//	printf("%p\n", arr);
//	printf("%p\n", num);
//
//	// arr = &num;				// 에러발생
//
//	return 0;
//}
//
//
//================================================== =
//
//
//[포인터를 배열처럼 사용하는 법]
//
//
//#include <stdio.h>
//int main(void) {
//
//	int a[] = { 10,20,30,40,50 };
//	int* p;
//
//	// 위에서 했던 것처럼, 배열의 이름 자체로 첫번째 요소의 주소값을 나타냄.
//	// 즉, 이경우는 배열의 첫번재 요소의 주소값과 포인터의 연결을 의미함.
//
//	p = a;
//
//	// 이 경우는 배열 전체의 주소를 나타내는 것처럼 표현해둔 건데
//	// 실제로 이 경우에도 배열 전체의 주소를 p 포인터와 연결하는게 아니라
//	// 배열의 첫번째 요소의 주소값과 연결하는 과정임
//	// 그렇지만 이렇게도 사용가능함
//
//	p = &a;
//
//	printf("a[0] = %d a[1] = %d a[2] = %d\n", a[0], a[1], a[2]);   // a[0] = 10, a[1] = 20, a[2] = 30
//	printf("p[0] = %d p[1] = %d p[2] = %d\n", p[0], p[1], p[2]);
//
//	p[0] = 60;
//	p[1] = 70;
//	p[2] = 80;
//
//	printf("a[0] = %d a[1] = %d a[2] = %d\n", a[0], a[1], a[2]);
//	printf("p[0] = %d p[1] = %d p[2] = %d\n", p[0], p[1], p[2]);
//
//	return 0;
//}
//
//
//- 참고 ))
//
//- 포인터 p가 배열 전체를 가리키게 하려면
//- 배열의 크기를 알아야 한다.
//- p를 배열 끝까지 이동시키는 방식을 사용
//
//- Ex) 배열 a가 5개의 요소를 가지고
//- p를 배열의 끝가지 이동시키려면 다음과 같이 해야 함
//
//p = &a[4]
//
//- p가 배열의 마지막 요소를 가르킴
//- p--와 같은 연산을 사용해서 배열의 처음부터 끝까지 순회할수 있음
//
//
//
#include <stdio.h>
int main(void) {

	int a[5] = { 10,20,30,40,50 };
	int* p = &a[4];

	while (p >= a) {
		printf("%d\n", *p);
		p--;
	}
	return 0;
}