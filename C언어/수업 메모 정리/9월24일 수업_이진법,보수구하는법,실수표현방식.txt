

// 01	 이진 데이터(2진수)의 양수 표현 방식
//		 10진수 --> 우리가 일반적으로 사용하고 있는 수
//		 0-9까지로만 표현한 수 


//	2진수 --> 0과 1로만 표현한 수
// 
// 컴퓨터는 10진수 데이터를 2진수 데이터로 변환하여 저장되는데
// 이때 2진수로 변환된 데이터 하나를 담는 최소 공간단위 == 비트(bit)
// 
// 
// 1 byte == 8bit
// 
// 
// 
// 2진수를 10진수로 변환할 때 계산하는 방법
// 1	1	1	1	1	1	1	1
// 128	64	32	16	8	4	2	1 ==> 총합 : 255
// 
// 
// 		
// 10진수를 2진수로 변환하는 문제
// 72		->		 0100 1000
// 42		->		 0010 1010
// 160		->		 1010 0000



// 2진수를 10진수로 변환하는 문제
// 11000001		->		193
// 01011101		->		93
// 00001011		->		11
// 10101110		->		174
// 11101101		->		237


//-------------------------------------------------------


// 02	 이진 데이터(2진수)의 음수 표현 방식

// CPU는 가산기(가산회로)에 의해서 데이터에 대한 덧셈연산을 할 수 있다.
// CUP는 감산기(감산회로)에 의해서 데이터에 대한 뺄셈연산을 할 수 없다.
// CPU는 애초에 가연산에 특화되어 있는 명령 처리 장치이다.


// 음수를 표현하는 방법에는 3가지가 있음.
 
// 1. 부호가 있는 절대치	
//	EX) +2		-->		0 000 0010
//		+1		-->		0 000 0001
//		+0		-->		0 000 0000

//	    -0		-->		1 000 0000
//		-1		-->		1 000 0001
//		-2		-->		1 000 0010

// 2. 1의 보수
// 3. 2의 보수


// 8비트공간에 음수를 저장할 수 있다.
// 8비트에서 부호를 지원한다면 제일 앞 비트는 부호 비트이다.

// (Signed, Unsigned) : 자료형 
// Signed : 부호 0 즉 음수, 0, 양수 사용
// Unsigned : 부호 X 즉	   0, 양수 사용
// 부호비트가 0이면 양수 <---------------------> 1이면 음수

	
// 컴퓨터의 뺄셈 처리는 '보수' 개념을 이용해서 음수를 양수화 하여
// 계산하는데 이는 뺄셈 결과와 동일한 결과가 나옴.

// A -  B는 A + (B의 보수)로 바꾸어 계산함

// 보수란? : 각 자리의 숫자의 합이 일정한 수가 되게 하는 수
//			즉 어느 수에 대한 반전, 뒤집는 개념

// N진수라면 보수가 두가지 존재.
// 1. N - 1의 보수
// 2. N의 보수
// EX) 10진수에는 10의 보수와 9의 보수가 존재
//		2진수에는 2의 보수와 1의 보수가 존재
// 
// 1에 대한 10의 보수는 9
// 2에 대한 10의 보수는 8
// 3에 대한 10의 보수는 7
// 
// 3에 대한 9의 보수는 6
// 5에 대한 9의 보수는 4 

// 33에 대한 9의 보수는 66 --> 6(9-3) 6(9-3)
// 33에 대한 10의 보수는 67

// N의 보수는 == N - 1의 보수에서 1을 더했을 때의 값
// N의 보수는 '자릿수가 올라가는 수'

//--------------------------------------------------------

// 1에 대한 1의 보수는 0
// 0에 대한 1의 보수는 1

// 1) 1의 보수 구하는 법

// 1의 보수 : 각 자릿수의 값이 모두 1인 수에서 해당 2진수를 뺀 수
//			쉽게 말해 합쳐서 111	1111이 되는 수


//		10진수 --->		2진수
//		5진수  --->		0000 0101


// EX)	5에 대한 1의 보수를 구하는 법
//		1111 1111		-->		모두가 1인 수
//		0000 0101		-->		해당 2진수(5)
// 
//------------------------------------------------

//		1111 1010		--->	5에대한 1의 보수 == -127 + 64 + 32 + 16 + 8 + 0 + 2 + 0 == -5
//		1111 1011		--->	5에대한 2의 보수 == -128 + 64 + 32 + 16 + 8 + 0 + 2 + 0 == -5



// 2) 1의 보수를 간단하게 구하는 법

// 해당 2진수를 반전시키면 1의 보수
//		10진수 -->	2진수
//	EX) 5	   -->  101
// // 10진수 5에 대한 1의 보수는 010
//---------------------------------------------


// 3) 2의 보수 구하는 법

// 1의 보수에서 1을 더한 값과 같다.

// 자리 올림이 생기면 앞에 있는 비트를 삭제 ==> 000
// 즉 결과값이 0이 됨.

// 10진수 5에 대한 2의 보수는 011
// 
// 즉	5	-	5		==	0
// 
// 101 + 5에 대한 2의 보수 (011) ==>	1000

//-----------------------------------------------

// 5라는 10진수를 2진수로 변환하면
//	0	0	0	0		0	1	0	1		== 5
//	1	1	1	1		1	0	1	0		== 5에대한 1의 보수( 비트를 반전시킨 것과 결과가 동일)
// 1	1	1	1		1	0	1	1		== 5에 대한 2의 보수 (2의 보수는 1의 보수에서 1을 더한 값과 동일)
//											== 5와 5에 대한 2의 보수의 합 == 0
// 
//------------------------------------------------

// 각각 곱하기 후 더하기
// -128 + 64 + 32 + 16 + 8 + 0 + 2 + 1 == -5


//-------------------------------------------------------

// 54 - 34  = 20
// 34에 대한 9의 보수 = 65
// 34에 대한 10의 보수 = 66
// 54 + 66 = 120
//			= 20
// *증가된 자릿수는 버림


//--------------------------------------------------------


// 문제) 각 10진수를 2진수를 변환 후에 1의보수와 2의 보수를 구하시오

// 10		->		0000 1010 (이진수)
//			->		1111 0101(1의보수)
//				   +0000 0001
//				------------------------
// -10				1111 0110 (2의 보수)



// 8		->		0000 1000 (이진수)
//			->		1111 0111(1의보수)
//				   +0000 0001
//				------------------------
// -8				1111 1000 (2의 보수)




// 20		->		0001 0100 (이진수)
//			->		1110 1011(1의보수)
//				   +0000 0001
//				------------------------ 
// -20				1110 1100 (2의 보수)




// 120		->		0111 1000 (이진수)
//			->		1000 0111(1의보수)
//				   +0000 0001
//				------------------------ 
// -120				1000 1000 (2의 보수)




// 97		->		0110 0001 (이진수)
//			->		1001 1110(1의보수)
//				   +0000 0001
//				------------------------
// -97				1001 1111 (2의 보수)




// 42		->		0010 1010 (이진수)
//			->		1101 0101(1의보수)
//				   +0000 0001
//				------------------------
// -42				1101 0110 (2의 보수)




----------------------------------------------------------------------------------------



 03 실수 표현 방식

 실수의 범위는 무한대에 가깝기 때문에 제한된 공간을 가진 컴퓨터는
 모든 범위의 수를 담기란 불가능하다.


 float --> 4byte, 6-8자리까지 오차없이 담음
 double --> 8byte


 따라서 근사값, 즉, 소수점 이하 (가수부) 유효범위까지만 실수값을 저장하고
 나머지 부분에 있어서는 오차가 발생하여 나타난다.
 따라서, 반복적인 실수 연산처리는 오차가 나타날 수 밖에 없다.

 실수값의 소수점 위치 지정 방식은 두가지가 있다.
 
 1. 고정소수점 : 데이터와 관계없이 소수점 위치가 고정
	       값을 변동없이 저장하기에 저장 속도가 빠르다.

 2. 부동소수점 : 데이터 값에 따라 소수점의 위치가 변경
	        값을 변경할 수 있기에 저장 속도가 느리다.






