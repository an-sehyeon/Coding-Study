

 [ 포인터의 연산 ]

 - 포인터의 증가는 일반 변수와는 다름.
 - 가리키는 포인터의 자료형만큼 증가한다

 - 포인터		++연산 이후 값
 - char		1
 - short		2
 - int		4
 - float		4
 - double	8	


 #include <stdio.h>
 int main() {

	char* pc;				// char형 pc라는 포인터 변수 생성
	int* pi;				// int형 pi라는 포인터 변수 생성
	double* pd;			// double형 pd라는 포인터 변수 생성

	pc = (char*)10000;			// 정수를 포인터 변수의 데이터 형식의 맞게 형변환  
	pi = (int*)10000;			// 즉 그 형태로 만드는 것 == char형식의 포인터로 캐스팅한다고 함
	pd = (double*)10000;		

	
	printf("증가 전 pc = %p, pi = %p, pd = %p\n", (void*)pc, (void*)pi, (void*)pd);
	// %p서식문자는 포인터 변수의 메모리 주소를 출력하기 위함
	// (void)는 포인터가 어떤 타입의 자료형을 가지고 있던 주소를 올바르게 출력할 수 있게 해줌


	pc++;				// pc변수에 1을 더해줌
	pi++;				// pi변수에 1을 더해줌
	pd++;				// pd변수에 1을 더해줌

	printf("증가 후 pc = %p, pi = %p, pd = %p\n", (void*)pc, (void*)pi, (void*)pd);
	// 각각의 변수에 1을 더하면 포인터의 자료형의 타입에 따라 수가 더해진다.

	return 0;
 }


===================================================


 [ 문제 ]

 - 1. 변수 x를 10으로 초기화
 - 2. int형 포인터 변수 ptr을 선언하고 x의 주소를 참조
 - 3. x의 값 출력
 - 4. ptr의 값 출력
 - 5. x의 주소값 출력
 - 6. ptr이 가리키는 주소값 출력
 - 7. ptr의 주소값 출력 


 #include <stdio.h>
 int main(void) {

	int x = 10;				
	int* ptr = &x;				

	// 포인터 : 메모리 주소값을 저장하고 메모리 내의 데이터를 간접적으로 참조하는 , 접근하는 것
	// *(포인터 연산자) : 그 변수의 값

	// 변수의 값
	printf("x의 값 : %d\n", x);

	// 포인터의 값		
	printf("ptr의 값 출력 : %d\n", *ptr);

	// 변수의 주소 값	
	printf("x의 주소 값 출력 : %p\n", &x);

	// 변수의 위치값을 포인터 형태로(포인터 변수 사용) 출력		
	printf("ptr이 가리키는 주소의 값 : %p\n", ptr);

	// 포인터의 주소 값
	printf("ptr의 주소 값 출력 %p\n", &ptr);



	return 0;
 }

===================================================


 [ 포인터와 배열의 관계 ]

 - 1. 배열의 이름은 포인터 변수 역할을 하며 배열이 시작되는 메모리의 주소를 확인할 수 있다.
 - 2. 배열의 이름은 값을 저장할 수는 없다.

 - 인덱스 번호를 통해 각 요소에 순차적인 접근이 가능한 이유는 배열의 각 요소가 메모리 공간에 나란히 
  놓여있기 때문.


 #include <stdio.h>
 int main(void) {

	int arr[3] = { 10,20,30, };		// arr라는 배열에 3크기만큼 10,20,30의 데이터를 넣어줌

	printf("%d\n", arr[0]);		// arr[0]의 값인 10을 출력
	printf("%d\n", arr[1]);		// arr[1]의 값인 20을 출력
	printf("%d\n", arr[2]);		// arr[2]의 값인 30을 출력

	return 0;
 }


===================================================


 [ 배열의 주소 확인 ]

 #include <stdio.h>
 int main(void) {

	int arr[3] = { 10,20,30 };

	printf("배열 각 요소의 주소 확인\n");
	printf("배열의 이름 : %p\n", arr);		// 배열의 이름 arr의 주소와 배열의 첫번째 주소는 동일함
	printf("첫번째 요소 : %p\n", &arr[0]);		// 배열이 int형이기 때문에 첫번째 주소에서 순차적으로 4바이트씩 증가
	printf("두번째 요소 : %p\n", &arr[1]);
	printf("세번째 요소 : %p\n", &arr[2]);

	return 0;
 }


 - 실행결과에서 KeyPoint
 - 1. 각 요소의 주소값을 보면 순차적으로 4바이트씩 증가함.
 - 2. 배열의 이름은 그 자체로 포인터 변수의 역할을 하며,
     이는 배열의 첫번째 요소의 메모리 주소값과 동일
 - 3. 배열명을 포인터 상수(Constant Pointer)라고 함. ####

===================================================


 [ 참조 타입과 원시 타입 ]

 - 원시 타입이란 프로그래밍 언어에서 기본적으로 제공하는 데이터 유형
	보통 낮은 수준의 데이터 유형 (각 자료형들)

 - 참조란 = 변수나 메모리 위치에 접근하여 해당 데이터를 읽거나 수정하는 것을 의미
 - 참조 타입이란 프로그래밍 언어에서 변수가 메모리의 주소(참조)를 저장하는 데이터 유형

 
 #include <stdio.h>
 int main(void) {

	
	// java나 python에서는 배열은 참조타입.
	// c에서는 값 타입으로 취급
	// --> 포인터는 참조타입

	int arr[1] = { 3 };

	int num = 3;
	printf("%p\n", arr);
	printf("%p\n", num);

	// arr = &num;				// 에러발생

	return 0;
 }


===================================================


 [ 포인터를 배열처럼 사용하는 법 ]

 
 #include <stdio.h>
 int main(void) {

	int a[] = { 10,20,30,40,50 };
	int* p;

	// 위에서 했던 것처럼, 배열의 이름 자체로 첫번째 요소의 주소값을 나타냄.
	// 즉, 이경우는 배열의 첫번재 요소의 주소값과 포인터의 연결을 의미함.
	
	p = a;

	// 이 경우는 배열 전체의 주소를 나타내는 것처럼 표현해둔 건데
	// 실제로 이 경우에도 배열 전체의 주소를 p 포인터와 연결하는게 아니라
	// 배열의 첫번째 요소의 주소값과 연결하는 과정임
	// 그렇지만 이렇게도 사용가능함

	p = &a;

	printf("a[0] = %d a[1] = %d a[2] = %d\n", a[0], a[1], a[2]);   // a[0] = 10, a[1] = 20, a[2] = 30
	printf("p[0] = %d p[1] = %d p[2] = %d\n", p[0], p[1], p[2]);
	
	p[0] = 60;
	p[1] = 70;
	p[2] = 80;

	printf("a[0] = %d a[1] = %d a[2] = %d\n", a[0], a[1], a[2]);
	printf("p[0] = %d p[1] = %d p[2] = %d\n", p[0], p[1], p[2]);	

	return 0;
 }


 - 참고 ))

 - 포인터 p가 배열 전체를 가리키게 하려면
 - 배열의 크기를 알아야 한다.
 - p를 배열 끝까지 이동시키는 방식을 사용
 
 - Ex) 배열 a가 5개의 요소를 가지고
 -     p를 배열의 끝가지 이동시키려면 다음과 같이 해야 함

	 p = &a[4]

 - p가 배열의 마지막 요소를 가르킴
 - p--와 같은 연산을 사용해서 배열의 처음부터 끝까지 순회할수 있음



 #include <stdio.h>
 int main(void) {

	int a[5] = { 10,20,30,40,50 };		// 배열a에 정수 5개 저장
	int* p = &a[4];			// 포인터p는 배열a참조

	while (p >= a){			// p가 a와 같아질때까지 배열 4번째 위치한 값부터
		printf("%d\n", *p);		// 역순으로 출력
		p--;
	}
	return 0;
 }