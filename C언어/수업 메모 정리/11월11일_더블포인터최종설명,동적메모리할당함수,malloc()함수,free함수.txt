
 [ 더블포인터 복습 ]


 #include <stdio.h> 
 int main(void) {

	int value = 32;
	int* ptr;
	ptr = &value;

	int** dptr;
	dptr = &ptr;

	printf("ptr : %d (value의 주소값)\n", ptr);					// value 주소 값
	printf("*ptr : %d (value주소 안에 있는 값)\n", *ptr);				// value주소 안에 있는 값
	printf("dptr : %d (ptr의 주소값)\n", dptr);					// ptr의 주소값
	printf("*dptr : %d (value의 주소값)\n", *dptr);					// value의 주소값
	printf("**dptr : %d (ptr이 가리키고 있는 value주소 안에 있는 값)\n\n", **dptr);	// ptr이 가리키고 있는 value주소 안에 있는 값

	char id[30] = { "ansehyddffcc" };
	char* na;
	na = &id;

	char** da;
	da = &na;

	char ma[3] = { *(na + 4), *(na + 5) };

	printf("na : %p  (id의 주소값)\n", (void*)na);				// id의 주소 값
	printf("*na : %s (id 주소안에 있는 값)\n", na);				// id 주소안에 있는 값
	printf("da : %p (na의 주소값)\n", (void*)da);				// na의 주소 값
	printf("*da : %p (id의 주소값)\n", (void*)*da);				// id의 주소 값
	printf("**da : %s (na가 가리키고 있는 id주소 안에 있는 값)\n", *da);		// na가 가리키고 있는 id주소 안에 있는 값
	printf("ma(id의 5,6번째 문자) : %s\n", ma);				// id 값의 5번,6번째 인덱스 문자 출력




	int x = 100;
	int* ptr = &x;
	int** doubleptr = &ptr;
	int* ptr2;
	ptr2 = *doubleptr;


	x == x의 값
		* ptr == x의 값 == ptr이 가리키는 주소값(x의 메모리 주소)의 그 안에 값(100)
		* *doubleptr == x의 값 == doubleptr이 가리키는 주소값(ptr의 주소값)의
		안에 값(x의 메모리 주소값)의
		그 안에 값(100)

		& x == x의 메모리 주소값
		ptr == x의 메모리 주소값
		* doubleptr == x의 메모리 주소값 == doubltepr이 가리키는 주소값(ptr의 메모리 주소값)의
		그안에 값(x의 메모리 주소값)

		& ptr == ptr의 주소값
		doubleptr == ptr의 주소값

		& doubleptr == doubleptr의 주소값
		return 0;
 }




=================================================================

 [ 동적 메모리 할당 ]

 - 다차원 배열과 같은 다차원 데이터 구조를 동적 할당 및 해제할 때 사용

		### include<stdlib.h> ### 헤더파일
	
 - c와 c++ 프로그래밍에서 사용되는 표준 라이브러리 헤더 파일 중 하나
 - 메모리 동적 할당과 관련된 함수들 + 다양한 유틸리티 함수들이 선언되어 있음.
 
 - 1. 동적 메모리 할당 함수
 - 프로그램 실행 중에 동적으로 메모리를 할당하고 해제
 - EX) malloc(), calloc(), realloc(), free() 등

 - 2. 난수 함수
 - 난수를 생성하고 시드 값을 설정할 수 있음.
 - EX) rand(), srand()

 - 이를 제외하고도 환경 관련 함수, 프로세스 관련 함수, 표준 데이터 타임 및 메크로 등의 함수들이 많음. 

=================================================================



 [ 동적 할당 함수 ]

 - 1. malloc() = 동적 메모리 할당을 힙에 수행하고 그 메모리의 시작 주소를 반환하는 함수
 		스택 메모리와는 달리 프로그램 실행 중에 메모리가 할당되고 해제

 - 2. free() = 동적으로 할당된 메모리를 해제하기 위해 사용하는 함수
		힙에 할당된 메모리 블록을 운영체제에 반환 --> 메모리 누수를 방지


 #include <stdio.h>
 #include <stdlib.h>
 int main() {

	int* myArray;					// 정수형 데이터를 가리키는 포인터 선언

	// 메모리 할당
	int size = 5;					// 배열의 크기
	myArray = (int*)malloc(size * sizeof(int));		// malloc함수를 사용하여 size(5) * int형크기(4) = 20크기만큼의 메모리를 할당
							// malloc함수는 기본적으로 void형으로 정의되기때문에 형변환 필요
	if (myArray == NULL) {
		printf("메모리 할당에 실패했습니다.\n");
		return 1;
	}

	// 할당된 메모리에 데이터 저장
	for(int i = 0; i < size; i++){
		myArray[i] = i * 10;
	}

	// 할당된 메모리의 내용 출력
	printf("할당된 메모리의 내용 : ");
	for (int i = 0; i < size; i++) {
		printf("%d ", myArray[i]);
	}
	printf("\n");

	free(myArray);
	myArray = NULL;					// 댕글링 포인터를 방지하기 위해 포인터를 NULL로 변경
	return 0;
 }

 

=================================================================

 [ 댕글링 포인터 (Dangling Pointer) ]

 - 해제된 메모리를 가리키거나 유효하지 않은 메모리 주소를 참조하는 포인터를 가리킴
 
 - 다른 말로 이미 해제된 메모리를 참조하려고 시도할 때 발생하는 상황
 
 - 해제한 후 해당 메모리를 더 이상 사용하지 말아야함.
 - 하지만 때때로 포인터가 여전히 그 메모리 주소를 참조할 때가 있음.
 - 이러한 상황을 댕글링 포인터라고 함.
 

=================================================================

 [ free() 함수의 필요성 ]

 - 1. 메모리 누수 방지
 - 메모리를 할당(저장)하고 그걸 없애지 않으면 불필요한 메모리 차지가 일어남.
 - 이게 반복이 되면 프로그램이 할당할 수 있는 메모리가 없어짐 --> 메모리 누수 야기

 - 2. 댕글링 포인터 방지
 - 메모리 해제 --> 그 메모리를 가리키는 포인터는 더이상 유효x
 - 따라서 댕글링 포인터 문제 방지!

 - 3. 메모리 관리
 - 메모리 관리에 효율적임. 사용가능한 메모리 블록들을 유지하고 
   새로운 메모리 요청 처리 또한 가능하게 됨.


=================================================================


 [ 동적 메모리 할당 예제 ]

  

 #include <stdio.h>
 #include <stdlib.h>
  int main(void) {

	int rows = 3;					// 행을 나타낼 변수 3으로 초기화
	int cols = 4;					// 열을 나타낼 변수 4로 초기화

	int** matrix = (int**)malloc(rows * sizeof(int*));	// 정수형 데이터를 가리키는 더블포인터 matrix변수의 배열 크기 설정
	for (int i = 0; i < rows; i++) {			// i가 3까지 증감
		matrix[i] = (int*)malloc(cols * sizeof(int));	// malloc함수를 사용하여 cols(4) * sizeof(int)는 4 = 16바이트, 한 행에 16바이트가 들어감
	}						// 이차원 배열 설정, 배열안에 배열 설정

	// 동적으로 할당된 2D 배열에 값 설정
	for (int i = 0; i < rows; i++) {			// i가 3이 될때까지 증감
		for (int j = 0; j < cols; j++) {		// j는 4가 될때까지 증감
			matrix[i][j] = i * cols + j;		// i(0) * cols(4) + j(0) = 0행0열의 값은 0, 0행1열의 값은 1, 
							  i(1) * cols(4) + j(0) = 1행0	열의 값은 4
		}					// j는 4가 될때까지 증감하고 4가 되면 for문을 빠져나와 i가 다시 처음 for문으로 돌아가
	}						// 1이 증가하면 j는 다시 for문 반복


	// 할당 및 설정된 2D 배열 출력
	for (int i = 0; i < rows; i++) {
		for (int j = 0; j < cols; j++) {
			printf("%d	", matrix[i][j]);
		}
		printf("\n");
	}

	// 메모리 해제
	for (int i = 0; i, rows; i++) {
		free(matrix[i]);
	}
	free(matrix);
	return 0;

 }






 #include <stdio.h>
 #include <stdlib.h>
 int main() {

	int rows = 5;
	int cols = 3;


	int** chart = (int**)malloc(rows * sizeof(int*));
	for (int i = 0; i < rows; i++) {
		chart[i] = (int*)malloc(cols * sizeof(int));
	}

	for (int i = 0; i < rows; i++) {
		for (int j = 0; j < cols; j++) {
			chart[i][j] = i * cols + j+10;
		}
	}

	for (int i = 0; i < rows; i++) {
		for (int j = 0; j < cols; j++) {
			printf("%d	", chart[i][j]);
		}
		printf("\n");
	}
	

	for (int i = 0; i < rows; i++) {
		free(chart[i]);
	}
	free(chart);

	return 0;
 }

