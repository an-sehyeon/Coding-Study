
 [ 언어의 메모리 구조 ]

 	### 메모리의 필요성 ###
 - 프로그램을 실행할 때 먼저 프로그램을 메모리에 로드(Load),
  즉 RAM(Random Access Memory)에 불러와 복사해둬야함.
 
	### 메모리 로드(Memory-Load) ###
 - 프로그램을 실행하거나 데이터를 다룰 때, 해당 프로그램이나 데이터를 하드 디스크,
   SSD, 또는 다른 저장 매체에서 메모리로 복사하는과정을 "로드한다"라고 표현함
   RAM은 하드 디스크보다 훨씬 빠른 읽기 및 쓰기 속도를 제공함. 


==============================================================================


 [ 1. 코드 영역(Code Segment ]

 - 실행할 프로그램의 기계어 코드가 저장되는 메모리 영역으로 텍스트(Code) 영역이라고도 함.
 
 - 프로그램이 실행될 때 CPU(Central Processing Unit), 즉 중앙처리 장치는
   코드 영역에 저장된 명령어를 하나씩 가져가저 정해진 순서대로 실행함.
 - 이를 절차 지향이라고 부름

==============================================================================

 [ 2. 데이터 영역 (Data Segment) (전역 변수 영역) ]

 - 프로그램의 전역 변수와 정적(static) 변수가 저장되는 영역임.
 - 프로그램 시작과 동시에 메모리 공간에 할당되며, 프로그램이 종료되면 소멸함.
 - 프로그램 어디에서든 접근 할 수 있다.

 - 초기화된 데이터와 초기화되지 않은 데이터 영역으로 나뉨.
 - 초기화된 데이터는 프로그램 시작 시 초기값을 가지며, 
   초기화되지 않은 데이터는 0 또는 NULL값으로 초기화됨.

==============================================================================

 [ 3. 스택 영역 (stack) ]

 - 스택 ((stack) : 데이터를 쌓는 자료구조
 - 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역임.
 - 함수의 호출과 함께 할당도며, 함수의 호출이 완료되면 소멸함.
 - 스택 영역에 저장되는 함수의 호출 정보를 스택 프레임(Stack Frame)이라고 함.


	## 스택 프레임 (Stack Frame) ##
 - 함수가 호출되면 스택에는 함수의 '매개변수', 호출이 끝난 뒤 돌아갈 '반환 주소값', 함수에서 선언된
  '지역변수' 등이 저장됨.

 - 스택 영역에 차례대로 저장되는 함수의 호출정보 및 상태정보를 스택 프레임이라고 하며, 스택 프레임에 저장.
 
 - 후입선출 방식덕분에 함수가 호출되고 호출되기 이전 상태로 되돌아 갈 수 있음.



	## 높은 주소와 낮은 주소 ##
 - 메모리 주소는 아래로 갈수록 증가, 위로 갈수록 감소함

 - 스택의 맨 위(가장 낮은 주소)는 현재 실행 중인 함수의 스택 프레임이 위치하는 지점이고 이 위에
   새로운 스택 프레임이 쌓임.

 - '높은 주소'와 '낮은 주소'는 메모리 주소의 상대적 위치, 즉 할당 방향을 나타내고 컴퓨터 아키텍처에 따라 따름.
 - 일반적으로 x86 아키텍처에서는 스택이 높은 주소에서 낮은 주소로 할당.
 - 컴퓨터 아키텍처 및 운영 체제에 따라 다를 수 있으며, 주소의 방향을 나타냄.
 - 스택의 "높은 주소"는 일반적인 메모리에서의 "높은 주소"와 반대 개념으로,
   스택 메모리에서는 높은 주소가 낮은 메모리 주소를 가리킴.


	일반 메모리		스택 메모리
 (	높은 주소			낮은주소 <--- 스택 포인터가 가리키는 위치
 (					      (현재 실행 중인 함수의 스택 프레임이 위치하는 지점)
 (
 (
 (   	낮은 주소			높은 주소

 - 푸쉬(PUSH) 동작으로 데이터를 저장하고, 팝(pop)동작으로 데이터 인출
 - 후입선출(LIFO, Last-In First-Out) 방식에 따라 동작, 즉 가장 늦게 저장된 데이터가 가장 먼저 인출.
 - 새로운 데이터가 스택에 푸시될 때 스택 포인터가 감소하고, 데이터가 팝될 때 스택 포인터가 증가함.
 - 스택 영역은 메모리의 높은 주소에서 낮은 주소의 방황으로 할당 

 - 스택이 위에서 아래로 쌓이는 것은 스택 메모리를 효율적으로 사용하기 위함.
 - 스택이 아래에서 위로 쌓이면 스택의 크기를 미리 정할 필요 x, 즉, 스택이 필요한 만큼 메모리를 사용할 수 있음.
 - 스택의 크기를 동적으로 조정하기 위해 메모리를 아래에서 위로 할당하는 것이 효율적임.

==============================================================================

 [ 4. 힙 영역 (Heap) ]

 - 사용자가 직접 관리할 수 있고 관리해야만 하는 메모리 영역
 - 즉, 사용자에 의한 메모리 동적 할당 및 해제

 - 일반적으로 메모리 누수와 같은 문제를 방지하기 위해 힙에서 할당한 메모리는 반드시 프로그램에서 해제해야 함.
 - 힙 영역은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당

	## 동적할당 (Dynamic Allocation) ##
 - 데이터 영역과 스택 영역에 할당되는 메모리의 크기는 컴파일 타임(Compile Time)에 미리 결정
 - 힙 영역의 크기는 프로그램이 실행되는 도중인 런 타임(Run Time)에 사용자가 직접 결정
 - 이를 메모리의 동적 할당이라고 함.
 - EX) malloc()함수, free()함수, calloc()함수 등


==============================================================================

 [ 함수 ]

 - 함수(function)란? : 하나의 특정한 목적의 작업을 수행하기 위한 코드들의 집합
 - 이것 역시 프로그램의 일종인데, IDLE과 같은 개발자를 위한 Tool도 프로그램이지만
   함수는 그 내부에 좀더 작은 단위의 프로그램으로 볼 수 있다.

 - 즉 프로그램은 여러 개의 함수들로 이루어져 있다.
 - 제일 먼저 호출되는 함수는 main()함수

 - 함수는 모듈화에 사용됨
 
 - 함수 호출(function call)이란 ? : 간단히 말해서, 함수 사용을 위해서 함수를 부른다. 호출한다는 의미
 - 함수는 입력을 받아 출력을 생성하는데 이는 커피자판기로 예로 들 수 있다.
 - EX) 커피자판기에 동전을 넣는다 (입력)
 - EX) 내가 원하는 커피가 나온다 (출력)
 - EX) 입력값은 100원, 200원, 500원, 1000원 등이 있을 수 있고
 - EX) 출력값은 카라멜 마끼아또, 에스프레소, 아메리카노 등이 있을 수 있다.


==============================================================================

 [ 01 모듈 ]

 - 모듈이란 ? : 프로그래밍에서의 모듈은 프로그램을 구성하는 구성 요소의 일부
 	 -EX) 계산기의 더하기 기능, 빼기 기능 등등
 - 이 모듈은 관련 데이터와 함수들의 집합, 즉 이런것들이 모여서 모듈을 형성함.
 	 - EX) 더하기 기능은 여러 함수와 코드들이 합쳐져서 만들어진 기능
 - 모듈화란? : 각각의 기능들을 파일별로 나뉘어 놓은걸 모듈화라고 한다.
 	 - EX) 계산기의 더하기나 빼기, 나누기 기능들을 파일별로 나누어 관리하는 것이 모듈화했다 라고 함

 - 모듈러 프로그래밍 : 모듈 개념을 사용하는 프로그래밍 기법
 - 모듈화의 장범 : 하나의 프로그램(계산기)를 만들 때 이식, 확장, 유지보수 등이 좋도록 한다.  


==============================================================================

 [ 02 함수의 종류 및 형태 ]

 - 1. 사용자 정의 함수 : 개발을 위해 개발자가 직적 만드는 함수
 - 2. 라이브러리 함수 : 개발자들이 사용하기 편하게 미리 만들어져 제공되는 함수


 - 함수의 헤더 (function header)
 - 1. 반환형 : 반환형은 함수가 반환하는 값의 데이터 타입을 정의한다. 반환값이 없는 경우 void라는 반환형을 사용한다.

 - 2. 함수 이름 : 함수 이름은 함수를 호출하기 위한 식별자이다.
      함수 이름은 변수 이름과 마찬가지로 유효한 식별자로 작성되어야 한다.

 - 3. 매개 변수 : 매개 변수는 함수가 호출될 때 전달되는 값을 받아들이는 변수이다.
	매개 변수는 함수 내에서 지역 변수처럼 작동한다. 
        	함수 호출 시에는 매개 변수에 전달되는 값의 데이터 타입의 개수가 일치해야한다.

 - 함수의 몸체 (function body) ==> {}





 #include <stdio.h>

 int add(int x, int y) {			// 함수명 add 생성
	int sum = x + y;			// sum 지역변수는 x + y값
	return sum;			// sum변수값 리턴
 }

 int main() {

	int num1 = 3;			// num1 값에 인자값 3 
	int num2 = 5;			// num2 값에 인자값 5
	int result = add(num1, num2);	// add함수를 호출해 result변수에 대입 x,y인자값을 num1,num2값 대입
	printf("The result is %d\n", result);
	

	return 0;
 }

==============================================================================

 [ int main(void) ]

 - 실제로 void main()을 사용하면 오류가 나진 않음.
 - return type(반환 자료형)에 int를 사용하는 것은 표준 c에서는 정상적인 실행의 경우 main함수는 
   return 0을 하기로 약속되어 있기 때문 (이는 실행 성공을 의미)
 - 그러나 return 0;을 개발자가 하지 않아도 컴파일러가 허용하는 범위이기 때문에 return 0;없이도 실행이 가능

 - 또한 main()은 return 0을 하기 때문에 int main()으로 적어줘야하지만 void main()으로 적는 것 또한
   컴파일러가 허용하는 범위 내 이기에 에러없이 실행이 됨.

 - 추가적으로 main 함수가 반환되는 값을 사용하는 경우는 매우 드물기 때문에
   void main()은 일반적으로 프로그램의 실행에 아무런 문제가 없다.


==============================================================================

 [ 03 인수(argument)와 매개변수(parameter) ]

 - 인수란 ? : 함수 호출 시 함수로 값을 전달해주는 변수

 - 매개변수란 ? : 함수 호출 시 인수로 전달된 값을 함수 내부에서 사용할 수 있도록 하는 변수
 - 매개변수는 함수 내에서 지역변수로 사용됨.
 - 매개변수는 함수 호출 시에 전달된 인수(argument)값을 저장.


==============================================================================

 [ 04 지역변수(Local Variable) ]

 - 특정구역({}) 내에서 생성되어 그 구역에서만 사용 가능한 변수, 즉 함수 속에서 선언되어 함수 속에서만
  사용 가능한 변수
 - 함수나 {}이 끝나게 되면 메모리에서 소멸 


==============================================================================

 [ 05 전역변수 (Global Variable) ]

 - 어느 위치에서든 호출하면 사용이 가능한 변수 즉, 함수 밖에서 선언하여 클래스 전체에서 사용이 가능한 변수

 - 1. 전역변수는 프로그램 전체에서 사용 가능한 변수이다.
 - 프로그램이 종료될 때까지 메모리에서 유지된다.

 - 2. 전역변수는 프로그램 내에서 어디에서든지 사용할 수 있으므로,
      프로그램의 다른 부분에서 변수명이 중복되어 사용될 가능성이 있다.
      따라서 전연변수는 가능한 사용을 최소화해야 한다.


==============================================================================

 [ 06 void(빈, 비어있는) ]

 - 함수나 포인터를 정의할 때 사용한다.
 - 1. void 함수
 - 2. void 포인터


 - 1. 함수의 반환형으로 void를 사용하면, 해당 함수는 반환값이 없다는 것을 나타낸다.

 
 #include <stdio.h>
 void helloworld() {			// 함수 생성
	printf("hello world\n");	// hello world 문자 출력
 }
 int main(void) {

	helloworld();		// 함수 호출

 return 0;
 }



 - 2. 포인터로서의 void

 - 포인터를 선언할 때 void를 사용하면, 어떤 데이터 타입의 메모리 주소든 포인터 변수에 할당0
   이를 void 포인터라고 함.
 - void 포인터는 연산x, 그렇기 때문에 연산 가능한 데이터 타입으로 캐스팅하여 사용함.


 #include <stdio.h>
 int main() {

	int num = 10;
	float fnum = 3.14;

	void* ptr;				// 포인터형 prr변수
	ptr = &num;			// ptr을 num변수에 대입
	printf("num : %d\n", *(int*)ptr);	// 포인터 변수ptr을 int형으로 출력

	ptr = &fnum;			// ptr을 fnum변수에 대입
	printf("num : %f\n", *(float*)ptr);	// 포인터 변수 ptr을 float형으로 출력

	return 0;
 }

==============================================================================

 [ 07 static 변수 (정적 변수) ]

 - static은 프로그램의 수명 주기와 관련된 변수임.
 - static 변수는 프로그램이 실행되고 종료될 때까지 존재

 - 1. 수명 주기 : static 변수는 프로그램이 실행되고 종료될 때가지 메모리에 남아 있음.
      이는 해당 변수가 함수의 호출이 끝난 후에도 유지되며, 다음 번 함수 호출 시에도 이전 값이 유지된다는 것을 의미
 
 - 2. 스코프 : static 변수는 정의된 함수 내에서만 접근 가능
      다른 함수에서는 직접적으로 접근할 수 없음.

 - 3. 초기화 : static 변수는 한번만 초기화
      함수가 여러번 호출되더라도 static 변수의 초기화는 처음 호출 시에만 이루어짐.
 
 - 4. 저장 위치 : static 변수는 프로그램의 데이터 세그먼트(데이터 영역)에 저장됨.
      이는 프로그램의 시작 시에 할당되고 종료 시에 해제됨.



 #include <stdio.h>
 void test() {
	static int count = 0;		// 정적 변수 선언 및 초기화
	count++;				// count 변수는 계속 유지되며 값이 유지됨.
	printf("Count : %d\n", count);
 }
 int main(void) {
	test();				// Count : 1 출력
	test();				// Count : 2 출력
	test();				// Count : 3 출력
	return 0;
 }


==============================================================================

   함수 심화 


 [ 01 포인터와 함수 포인터 ]

 - 	## 포인터(Pointer) ##
 - 포인터는 메모리 주소를 저장하고 참조하는 변수
 - 메모리 주소는 변수, 배열, 구조체, 함수 등 다양한 데이터 요소의 위치를 가리킴


	## 포인터의 선언과 초기화 ##
 - 1. 포인터의 선언과 초기화
  int x = 10;	// 정수 변수 선언
  int* ptr;	// 정수 포인터 선언
  ptr = &x;	// 포인터에 변수 x의 주소를 할당

 - 1-1. 포인터를 사용하여 값 접근
  int value = *ptr;	// 포인터를 사용하여 x의 값을 읽음


 - 2. 포인터 연산
 - 포인터는 산술 연산을 수행할 수 있으며, 배열의 요소에 접근할 때 특히 유용
  int arr[] = {10, 20, 30, 40};	// 배열 선언
  int* ptr = arr;			// 배열의 첫 번째 요소를 가리키는 포인터
  int thirdElement = *(ptr + 2);	// 세 번째 요소에 접근


	## 함수 포인터(Function Pointer) ##
 - 함수 포인터는 함수의 주소를 저장하고 해당 함수를 실행할 수 있는 포인터
 - 함수 포인터를 사용하면 런타임에 다양한 함수를 선택적으로 호출할 수 있음
 - 함수 포인터는 콜백 함수, 동적 함수 호출, 이벤트 처리 등 다양한 상황에서 사용

 - 1. 함수 포인터의 선언

 int (*functionPtr) (int, int);		// int를 반환하고 int 두 개를 인수로 받는 함수 포인터 선언


 - 2. 함수 포인터에 함수 할당

 int add(int a, int b) {
   return a +b;
 }
 functionPtr = add;		// 함수 포인터에 add 함수 할당


 - 3. 함수 포인터를 사용하여 함수 호출

 int result = functionPtr(5,3);	// 함수 포인터를 사용하여 add 함수 호출

==============================================================================

 [ 02 콜백 함수 구현 ]

 - 콜백 함수 (callback Function) : 다른 함수에 의해서 호출되는 함수
 - 일반적으로 다른 함수의 작업 중에 특정 이벤트 또는 조건이 발생했을 때 호출되며,
 - 이때 콜백 함수는 특정 작업을 수행하거나 어떤 동작을 실행

 - 1. 이벤트 처리
 - 그래픽 사용자 인터페이스(GUI)에서 버튼 클릭 또는 마우스 이동과 같은 이벤트가 발생했을 때
   특정 함수를 호출하여 해당 이벤트를 처리

 - 2. 비동기 작업 (Asynchronous operation)
 - 여러 작업을 동시에 수행하거나, 작업을 순차적으로 실행하되 다른 작업의 완료를 기다리지 않는 방식
 - EX) 대규모 파일 다운로드, 네트워크 통신, 사용자 인터페이스 응답성(백그라운드 작업 처리),  
        병렬처리(다중 코어 CPU 활용 --> 여러 작업 병렬 실행)

 - 비동기 작업 ( 예 : 파일 다운로드)이 완료되면 완료 콜백 함수를 호출하여 작업 결과를 처리

 - 3. 사용자 지정 동작
 - 사용자가 원하는 동작을 콜백 함수로 정의하고 다른 함수(예 : 정렬 함수)가 이름 호출할 때 사용자 지정 동작을 실행



 #include <stdio.h>

 // 콜백 함수 시그니처 : 정수 2개를 입력으로 받고 정수를 반환하는 함수
 typedef int (*CallbackFunction) (int, int);

 int add(int a, int b) {
	return a + b;
 }

 int Multiply(int a, int b) {
	return a * b;
 }

 // 콜백 함수를 사용하는 함수
 int PerformOperation(int x, int y, CallbackFunction operation) {
	return operation(x, y);
 }

 int main() {
	int result1, result2;

	// 덧셈 콜백 함수를 사용
	result1 = PerformOperation(5, 3, add);
	printf("덧셈 결과 : %d\n", result1);

	// 곱셈 콜백 함수를 사용
	result2 = PerformOperation(5, 3, Multiply);
	printf("곱셈 결과 : %d\n", result2);

	return 0;
 }


 - CallbackFunction이라는 함수 포인터 타입을 정의하고, add 및 Multiply 함수를 콜백 함수로 사용
 - PerformOperation 함수는 이러한 콜백 함수를 사용하여 다양한 연산을 수행

==============================================================================


 [03 재귀 함수]

 - 재귀 함수 (Recursion Function)
 - 자기 자신을 직접 또는 간접적으로 호출하는 프로그래밍 기법
 - 함수 내에서 자신의 함수를 호출하는 기법이라고 생각하면 됨.
 - 문제 해결 혹은 동일한 알고리즘을 적용하는데 사용



	재귀 함수를 사용 x

 #include <stdio.h>
 int factorial(int n){			// factorial함수를 생성 int형 n이라는 매개변수 생성
	int result = 1;			
	for (int i = 1; i <= n; i++) {	// i가 n가 같을때까지 1씩 증감
		result *= i;		// i가 n과 같을때까지 곱해진 값을 result에 저장
 }
	return result;
 }
 int main(void) {				
	printf("5! = %d\n", factorial(5));	// factorial함수에 인자값 5 대입

 }



	재귀 함수를 사용 0 

 #include <stdio.h>
 int factorial(int n) {
	if (n == 0) {
		return 1;
 }
	else {
		return n * factorial(n - 1);
  }
 }
 int main(void) {

	printf("5! = %d\n",factorial(5));
	// 5 * factorial(4)
 }

==============================================================================


 [ 재귀 함수의 구조 ]

 - 재귀 함수는 항상 종료 조건을 가져야 함
 - 종료 조건이 없거나 잘못 구현된 경우, 함수가 무한히 호출되어 스택 오버플로우와 같은 오류를 일으킬 수 있음.

 - 재귀 함수를 사용할 때, 중요한 것은 각 호출이 서로 다른 문제 인스턴스를 다루는 것, 즉 각 호출이 독립적이라는 것을 의미.
 - 각 호출은 자체 스택 프레임을 가지며, 호출 간에 데이터를 공유하지 않아야 함.
 - 이것을 통해 작은 부분 문제를 해결하고 결합하여 원래 문제를 해결.


	피보나치 수열


 #include <stdio.h>

 int calculateSum(int n) {
	if (n == 1) {
		return 1;			// 재귀 종료 조건
	}
	else {
	return n + calculateSum(n - 1);	 // 자신을 다시 호출하면서 숫자를 더해감
  	}
 }
 int main() {
	int num;
	printf("양의 정수를 입력하세요: ");
	scanf_s("%d", &num);

	if (num < 1) {
		printf("양의 정수를 입력해야 합니다.\n");
	}
	else {
		int result = calculateSum(num);
		printf("1부터 %d까지의 합은 %d입니다.\n", num, result);
	}
	return 0;
 }

 - calculateSum 함수는 재귀적으로 호출되며, n이 1일 때 재귀가 종료


==============================================================================


 [ 04 배열과 함수 ]

 - 배열의 이름은 0번째 인덱스 요소의 위치값, 주소값을 나타냄.
 - 이때 포인터 변수를 선언하여 사용함.
 - 포인터와 배열의 관계에서 다루었던 내용들 
 - 포인터는 배열처럼 사용할 수 있다.



 #include <stdio.h>
 void printArray(int* arr, int size) {
	for (int i = 0; i < size; i++) {
		printf("%d", arr[i]);
	}
 }
 int main() {
	int arr[5] = { 1,2,3,4,5 };
	
	printArray(arr, 5);
 }

 - printArray 함수에서는 'arr' 배열의 첫 번째 요소를 가리키는
  포인터 변수 'arr'을 사용하여 배열의 모든 요소를 출력할 수 있다.


==============================================================================


 [ 문제 1 ]

 - 재귀 함수를 사용하여 주어진 배열에서 특정 값의 존재여부를 확인하는 C 프로그램을 작성
 - search 함수를 재귀 함수로 선언 및 정의하시오.
 - 1. 크기가 5인 정수형 배열 arr 선언
 - 2. 배열의 크기를 size에 초기화
 - 3. 내가 찾을 target 변수 초기화
 - 4. if문을 사용해서 내가 search 함수로 target을 찾는다면 1을 반환, 아니면 0을 반환
 - 5. target을 찾아서 1을 반환했을 때 if문에 들어와 target 출력, 아니면 target not found 출력

 - Tips) search()를 정의할 때, 재귀함수, 즉 자기 자신을 호출해야함.
	search()를 정의할 때, 내가 찾으려고 하는 target이 배열안에 있는지 확인하는 작업이 필요,
	size는 크기이므로 인덱스 번호로 이용


 #include <stdio.h>
 int search( int arr[],int size, int target) {

	// 배열의 요소에 target있다면? return 1
	// arr[0]이 target과 같나?
	// arr[1]이 target과 같나?
	// arr[2]이 target과 같나?
	// arr[3]이 target과 같나?
	// arr[4]이 target과 같나?
	// arr 배열의 요소와 target이 같은지에 대한 식을 세워야함
	// 배열의 요소에 target없다면? return 0 ==> 종료조건
		

	if ( size == 0 ) {			// 5크기의 배열 -1은 4, 4번째 인덱스 값이 target과 같은지의 조건식 
		return 0;
	}
	if(arr[size - 1] == target) {		// 4번째 인덱스에 해당하는 요소값이 target과 다르다면
		return 1;
	}

	return search(arr, size - 1, target);

 }

 int main(void) {
	int arr[] = { 1,2,3,4,5 };
	int size = sizeof(arr) / sizeof(arr[0]);		// 20bytd / 4 byte == 5
	int target = 3;
	
	if (search(arr,size, target)) {			// 만약에 target이 arr 배열에 있다면 이 코드를 수행
		printf("내가 찾을 타겟이 있습니다.");
	}
	else {					// 만약에 target이 arr 배열에 없다면 이 코드를 수행
		printf("내가 찾을 타겟이 없습니다.");
	}
 }


==============================================================================


 [ 문제 2 ]

 - 팩토리얼 함수

 - 팩토리얼 함수는 n이 양의 정수일 때 n!의 값을 계산하는 함수이다.
 - n!은 1부터 n까지의 모든 양의 정수를 곱한다.
 - 예를 들어 5! = 1 x 2 x 3 x 4 x 5 = 120

 - 재귀호출 함수를 사용하여 팩토리얼 함수를 구현해 보시오
 - 함수의 이름은 factorial로 하고, 매개변수로는 양의 정수 n을 받는다.



 #include <stdio.h>

 unsigned long long factorial(unsigned int n) {
	if (n == 0) {
		return 1;
	}
	else {
		return n * factorial(n - 1);
	}
 }

 int main(void) {

	unsigned int num;				//양수 데이터형 num 변수 생성
	printf("양의 정수를 입력하세요>>");
	scanf_s("%u", &num);

	unsigned long long result = factorial(num);
	printf("%u! = %llu\n", num, result);

 }

