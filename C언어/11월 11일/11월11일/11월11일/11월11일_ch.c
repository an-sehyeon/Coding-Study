//
//[더블포인터 복습]
//
//
//#include <stdio.h> 
//int main(void) {
//
//	int value = 32;
//	int* ptr;
//	ptr = &value;
//
//	int** dptr;
//	dptr = &ptr;
//
//	printf("ptr : %d (value의 주소값)\n", ptr);					// value 주소 값
//	printf("*ptr : %d (value주소 안에 있는 값)\n", *ptr);				// value주소 안에 있는 값
//	printf("dptr : %d (ptr의 주소값)\n", dptr);					// ptr의 주소값
//	printf("*dptr : %d (value의 주소값)\n", *dptr);					// value의 주소값
//	printf("**dptr : %d (ptr이 가리키고 있는 value주소 안에 있는 값)\n\n", **dptr);		// ptr이 가리키고 있는 value주소 안에 있는 값
//
//	char id[30] = { "ansehyddffcc" };
//	char* na;
//	na = &id;
//
//	char** da;
//	da = &na;
//
//	char ma[3] = { *(na + 4), *(na + 5) };
//
//	printf("na : %p  (id의 주소값)\n", na);				// id의 주소 값
//	printf("*na : %s (id 주소안에 있는 값)\n", na);			// id 주소안에 있는 값
//	printf("da : %p (na의 주소값)\n", da);				// na의 주소 값
//	printf("*da : %p (id의 주소값)\n", *da);				// id의 주소 값
//	printf("**da : %s (na가 가리키고 있는 id주소 안에 있는 값)\n", *da);	// na가 가리키고 있는 id주소 안에 있는 값
//	printf("ma : %s\n", ma);					// id 값의 5번,6번째 인덱스 문자 출력
//
//
//
//
//	int x = 100;
//	int* ptr = &x;
//	int** doubleptr = &ptr;
//	int* ptr2;
//	ptr2 = *doubleptr;
//
//
//	x == x의 값
//		* ptr == x의 값 == ptr이 가리키는 주소값(x의 메모리 주소)의 그 안에 값(100)
//		* *doubleptr == x의 값 == doubleptr이 가리키는 주소값(ptr의 주소값)의
//		안에 값(x의 메모리 주소값)의
//		그 안에 값(100)
//
//		& x == x의 메모리 주소값
//		ptr == x의 메모리 주소값
//		* doubleptr == x의 메모리 주소값 == doubltepr이 가리키는 주소값(ptr의 메모리 주소값)의
//		그안에 값(x의 메모리 주소값)
//
//		& ptr == ptr의 주소값
//		doubleptr == ptr의 주소값
//
//		& doubleptr == doubleptr의 주소값
//		return 0;
//}
//
//
//
//
//================================================================ =
//
//[동적 메모리 할당]
//
//- 다차원 배열과 같은 다차원 데이터 구조를 동적 할당 및 해제할 때 사용
//
//### include<stdlib.h> ### 헤더파일
//
//- c와 c++ 프로그래밍에서 사용되는 표준 라이브러리 헤더 파일 중 하나
//- 메모리 동적 할당과 관련된 함수들 + 다양한 유틸리티 함수들이 선언되어 있음.
//
//- 1. 동적 메모리 할당 함수
//- 프로그램 실행 중에 동적으로 메모리를 할당하고 해제
//- EX) malloc(), calloc(), realloc(), free() 등
//
//- 2. 난수 함수
//- 난수를 생성하고 시드 값을 설정할 수 있음.
//- EX) rand(), srand()
//
//- 이를 제외하고도 환경 관련 함수, 프로세스 관련 함수, 표준 데이터 타임 및 메크로 등의 함수들이 많음.
//
//================================================================ =
//
//
//
//[동적 할당 함수]
//
//- 1. malloc() = 동적 메모리 할당을 힙에 수행하고 그 메모리의 시작 주소를 반환하는 함수
//스택 메모리와는 달리 프로그램 실행 중에 메모리가 할당되고 해제
//
//- 2. free() = 동적으로 할당된 메모리를 해제하기 위해 사용하는 함수
//힙에 할당된 메모리 블록을 운영체제에 반환-- > 메모리 누수를 방지
//
//
//#include <stdio.h>
//#include <stdlib.h>
//int main() {
//
//	int* myArray;					// 정수형 데이터를 가리키는 포인터 선언
//
//	// 메모리 할당
//	int size = 5;					// 배열의 크기
//	myArray = (int*)malloc(size * sizeof(int));
//
//	if (myArray == NULL) {
//		printf("메모리 할당에 실패했습니다.\n");
//		return 1;
//	}
//
//	// 할당된 메모리에 데이터 저장
//	for (int i = 0; i < size; i++) {
//		myArray[i] = i * 10;
//	}
//
//	// 할당된 메모리의 내용 출력
//	printf("할당된 메모리의 내용 : ");
//	for (int i = 0; i < size; i++) {
//		printf("%d ", myArray[i]);
//	}
//	printf("\n");
//
//	free(myArray);
//	myArray = NULL;					// 댕글링 포인터를 방지하기 위해 포인터를 NULL로 변경
//	return 0;
//}
//
//
//
//================================================================ =
//
//[댕글링 포인터(Dangling Pointer)]
//
//- 해제된 메모리를 가리키거나 유효하지 않은 메모리 주소를 참조하는 포인터를 가리킴
//
//- 다른 말로 이미 해제된 메모리를 참조하려고 시도할 때 발생하는 상황
//
//- 해제한 후 해당 메모리를 더 이상 사용하지 말아야함.
//- 하지만 때때로 포인터가 여전히 그 메모리 주소를 참조할 때가 있음.
//- 이러한 상황을 댕글링 포인터라고 함.
//
//
//================================================================ =
//
//[free() 함수의 필요성]
//
//- 1. 메모리 누수 방지
//- 메모리를 할당(저장)하고 그걸 없애지 않으면 불필요한 메모리 차지가 일어남.
//- 이게 반복이 되면 프로그램이 할당할 수 있는 메모리가 없어짐-- > 메모리 누수 야기
//
//- 2. 댕글링 포인터 방지
//- 메모리 해제-- > 그 메모리를 가리키는 포인터는 더이상 유효x
//- 따라서 댕글링 포인터 문제 방지!
//
//- 3. 메모리 관리
//- 메모리 관리에 효율적임.사용가능한 메모리 블록들을 유지하고
//새로운 메모리 요청 처리 또한 가능하게 됨.
//
//
//================================================================ =
//
//
//[동적 메모리 할당 예제]
//
//

#include <stdio.h>
#include <stdlib.h>
int main(void) {

	int rows = 3;											// 행을 나타낼 변수 3으로 초기화
	int cols = 4;											// 열을 나타낼 변수 4로 초기화

	int** matrix = (int**)malloc(rows * sizeof(int*));		// 정수형 데이터를 가리키는 더블포인터 matrix변수의 배열 malloc함수를 통해 rows 크기 설정
	for (int i = 0; i < rows; i++) {						// i가 3까지 증감
		matrix[i] = (int*)malloc(cols * sizeof(int));		// malloc함수를 사용하여 cols(4) * sizeof(int)는 4 = 16바이트, 한 행에 16바이트(4개의 인덱스)가 들어감
	}														// 이차원 배열 설정, 배열안에 배열 설정

	// 동적으로 할당된 2D 배열에 값 설정
	for (int i = 0; i < rows; i++) {						// i가 3이 될때까지 증감
		for (int j = 0; j < cols; j++) {					// j는 4가 될때까지 증감
			matrix[i][j] = i * cols + j;					// i(0) * cols(4) + j(0) = 0행0열의 값은 0, 0행1열의 값은 1, i(1) * cols(4) + j(0) = 1행0열의 값은 4
		}													// j는 4가 될때까지 증감하고 4가 되면 for문을 빠져나와 i가 다시 처음 for문으로 돌아가
	}														// 1이 증가하면 j는 다시 for문 반복


	// 할당 및 설정된 2D 배열 출력
	for (int i = 0; i < rows; i++) {
		for (int j = 0; j < cols; j++) {
			printf("%d	", matrix[i][j]);
		}
		printf("\n");
	}

	// 메모리 해제
	for (int i = 0; i, rows; i++) {
		free(matrix[i]);
	}
	free(matrix);
	return 0;

}

